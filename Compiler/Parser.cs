/**
 * @author Antoine/Anthony Sébert
 */

using System;
using System.Collections.Generic;

namespace Compiler {
	/**
	 * Checks that the collection of tokens generated by the scanner follow the rules of the grammar.
	 * @see	Token
	 * @see	TokenKind
	 * @see	Scanner
	 */
	class Parser {
		/* ATTRIBUTES */
			/**
			 * Holds a reference to the scanner.
			 * @see	Scanner
			 */
			private Scanner scanner = null;
			/**
			 * Holds a collection of valid tokens.
			 * @see	Token
			 */
			private IEnumerator<Token> tokens = null;
		/* MEMBERS */
			// public
				// constructor
					/**
					 * Build a {@code Parser} instance.
					 * @param	_scanner	Scanner from which to perform the parsing process.
					 */
					public Parser(Scanner _scanner) {
						scanner = _scanner;
						//errorReporter = errorReporter;
						//previousLocation = Location.Empty;
						tokens = scanner.GetEnumerator();
					}
				// program parsing
					/**
					 * Parses a program from the beginning to the end.
					 */
					public void ParseProgram() {
						Compiler.Info(typeof(Parser).Name, "parsing Program", 1);
						tokens.MoveNext();
						//var startLocation = tokens.Current.Position.Start;
						ParseCommand();
					}
			// protected
				// parsing
					/**
					 * Checks that the given token matches the current stream of tokens, if not prints an error.
					 * @param expectedKinds	an array of expected token kinds.
					 */
					protected void Accept(params TokenKind[] expectedKinds) {
						foreach(var expected_kind in expectedKinds) {
							if(tokens.Current.Kind == expected_kind) {
								//previousLocation = tokens.Current.Position.Start;
								tokens.MoveNext();
							}
							else
								Console.WriteLine($"error : {expected_kind} expected, {tokens.Current.Kind} found");
						}
					}
					/**
					 * Fetches the next token from the source file.
					 */
					protected void AcceptIt() {
						//previousLocation = tokens.Current.Position.End;
						tokens.MoveNext();
					}
				// value-or-variable parsing
					/**
					 * Parses a variable name.
					 */
					protected void ParseVname() {
						Compiler.Info(typeof(Parser).Name, "parsing variable name", 1);
						ParseIdentifier();
					}
				// terminals parsing
					/**
					 * Parses an identifier, and constructs a leaf AST to represent it.
					 */
					protected void ParseIdentifier() {
						Compiler.Info(typeof(Parser).Name, "parsing identifier", 1);
						Accept(TokenKind.Identifier);
					}
					/**
					 * Parses an operator.
					 */
					protected void ParseOperator() {
						Compiler.Info(typeof(Parser).Name, "parsing operator", 1);
						switch(tokens.Current.Spelling) {
							case "+":
							case "-":
							case "/":
							case "*":
							case "<":
							case ">":
							case "=":
							case "==":
							case "+=":
							case "-=":
							case "/=":
							case "*=":
							case "<=":
							case ">=":
								AcceptIt();
								break;
							default:
								Compiler.Error(typeof(Parser).Name, 1, new string[]{
									tokens.Current.Position.Start.LineNumber.ToString(),
									tokens.Current.Position.Start.RowNumber.ToString(),
									tokens.Current.Spelling
								}, 1);
								break;
						}
					}
					/**
					 * Parses an integer literal.
					 */
					protected void ParseIntLiteral() {
						Compiler.Info(typeof(Parser).Name, "parsing integer literal", 1);
					}
				// command parsing
					/**
					 * Parses a command. Multiple tokens swallowed at once.
					 */
					protected void ParseCommand() {
						Compiler.Info(typeof(Parser).Name, "parsing command", 1);
						ParseSingleCommand();
						while(tokens.Current.Kind == TokenKind.Semicolon) {
							AcceptIt();
							ParseSingleCommand();
						}
					}
					/**
					 * Parses an expression. Multiple tokens swallowed at once.
					 */
					protected void ParseExpression() {
						Compiler.Info(typeof(Parser).Name, "parsing expression", 1);
						ParsePrimaryExpression();
						while(tokens.Current.Kind == TokenKind.Operator) {
							AcceptIt();
							ParsePrimaryExpression();
						}
					}
					/**
					 * Parses a primary expression.
					 */
					protected void ParsePrimaryExpression() {
						Compiler.Info(typeof(Parser).Name, "parsing primary expression", 1);
						switch(tokens.Current.Kind) {
							case TokenKind.IntLiteral:
								AcceptIt();
								break;
							case TokenKind.Identifier:
								AcceptIt();
								ParseVname();
								break;
							case TokenKind.Operator:
								AcceptIt();
								ParsePrimaryExpression();
								break;
							case TokenKind.LeftParenthese:
								AcceptIt();
								ParseExpression();
								Accept(TokenKind.RightParenthese);
								break;
							default:
								Compiler.Error(typeof(Parser).Name, 2, new string[]{
									tokens.Current.Position.Start.LineNumber.ToString(),
									tokens.Current.Position.Start.RowNumber.ToString(),
									tokens.Current.Kind.ToString(),
									TokenKind.IntLiteral.ToString(),
									TokenKind.Identifier.ToString(),
									TokenKind.Operator.ToString(),
									TokenKind.LeftParenthese.ToString(),
									tokens.Current.Kind.ToString()
								}, 1);
								break;
						}
					}
					/**
					 * Parses a declaration. Multiple tokens swallowed at once.
					 */
					protected void ParseDeclaration() {
						Compiler.Info(typeof(Parser).Name, "parsing declaration", 1);
						ParsingSingleDeclaration();
						while(tokens.Current.Kind == TokenKind.Semicolon) {
							AcceptIt();
							ParsingSingleDeclaration();
						}
					}
					/**
					 * Parses a single declaration.
					 */
					protected void ParsingSingleDeclaration() {
						Compiler.Info(typeof(Parser).Name, "parsing single declaration", 1);
						switch(tokens.Current.Kind) {
							case TokenKind.Const:
								AcceptIt();
								ParseIdentifier();
								if(tokens.Current.Spelling == "~")
									AcceptIt();
								ParseExpression();
								break;
							case TokenKind.Var:
								AcceptIt();
								ParseIdentifier();
								if(tokens.Current.Spelling == ":")
									AcceptIt();
								ParseIdentifier();
								break;
							default:
								Compiler.Error(typeof(Parser).Name, 2, new string[]{
									tokens.Current.Position.Start.LineNumber.ToString(),
									tokens.Current.Position.Start.RowNumber.ToString(),
									tokens.Current.Kind.ToString(),
									TokenKind.Const.ToString(),
									TokenKind.Var.ToString(),
									tokens.Current.Kind.ToString()
								}, 1);
								break;
						}
					}
					/**
					 * Parses a single command.
					 */
					protected void ParseSingleCommand() {
						Compiler.Info(typeof(Parser).Name, "parsing single command", 1);
						switch(tokens.Current.Kind) {
							case TokenKind.Identifier: {
								AcceptIt();
								ParseVname();
								Accept(TokenKind.Becomes);
								ParseExpression();
								Accept(TokenKind.LeftParenthese);
								ParseExpression();
								Accept(TokenKind.RightParenthese);
								break;
							}
							case TokenKind.Begin:
								AcceptIt();
								ParseCommand();
								Accept(TokenKind.End);
								break;
							case TokenKind.If:
								AcceptIt();
								ParseExpression();
								Accept(TokenKind.Then);
								ParseSingleCommand();
								Accept(TokenKind.Else);
								ParseSingleCommand();
								break;
							case TokenKind.While:
								AcceptIt();
								ParseExpression();
								Accept(TokenKind.Do);
								ParseSingleCommand();
								break;
							case TokenKind.Let:
								AcceptIt();
								ParseDeclaration();
								Accept(TokenKind.In);
								ParseSingleCommand();
								break;
							default:
								Compiler.Error(typeof(Parser).Name, 2, new string[]{
									tokens.Current.Position.Start.LineNumber.ToString(),
									tokens.Current.Position.Start.RowNumber.ToString(),
									tokens.Current.Kind.ToString(),
									TokenKind.Identifier.ToString(),
									TokenKind.Begin.ToString(),
									TokenKind.If.ToString(),
									TokenKind.While.ToString(),
									TokenKind.Let.ToString()
								}, 1);
								break;
						}
				}
	}
}
