/**
 * @author Antoine/Anthony Sébert
 */

using System;
using System.Collections.Generic;

namespace Compiler {
	/**
	 * Checks that the collection of tokens generated by the scanner follow the rules of the grammar.
	 * @see	Token
	 * @see	TokenKind
	 * @see	Scanner
	 */
	class Parser {
		/* ATTRIBUTES */
			/**
			 * Holds a reference to the scanner.
			 * @see	Scanner
			 */
			private Scanner scanner = null;
			/**
			 * Holds a collection of valid tokens.
			 * @see	Token
			 */
			private IEnumerator<Token> tokens = null;
		/* MEMBERS */
			// public
				// constructor
					/**
					 * Build a {@code Parser} instance.
					 * @param	_scanner	Scanner from which to perform the parsing process.
					 */
					public Parser(Scanner _scanner) {
						scanner = _scanner;
						tokens = scanner.GetEnumerator();
					}
				// program parsing
					/**
					 * Parses a program from the beginning to the end.
					 */
					public void ParseProgram() {
						Compiler.Info(typeof(Parser).Name, "parsing Program");
						// var previousLocation = Location.Empty;
						//var startLocation = tokens.Current.Position.Start; // ?
						ParseCommand();
					}
			// protected
				// tokens swallowing
					/**
					 * Checks that the given token matches the current stream of tokens, if not prints an error.
					 * @param expectedKinds	an array of expected token kinds.
					 */
					protected void Accept(TokenKind expectedKind) {
						if(tokens.Current.Kind == expectedKind) {
							var previousLocation = tokens.Current.Position.Start; // ?
						}
						else
							Compiler.Error(typeof(Parser).Name, 2, new string[]{
								tokens.Current.Position.Start.LineNumber.ToString(),
								tokens.Current.Position.Start.RowNumber.ToString(),
								tokens.Current.Kind.ToString(),
								expectedKind.ToString()
							});
						tokens.MoveNext();
					}
					/**
					 * Fetches the next token from the source file.
					 */
					protected void AcceptIt() {
						//var previousLocation = tokens.Current.Position.End; // ?
						tokens.MoveNext();
					}
				// command parsing
					/**
					 * Parses a command. Multiple tokens swallowed at once.
					 */
					protected void ParseCommand() {
						Compiler.Info(typeof(Parser).Name, "parsing command");
						AcceptIt();
						ParseSingleCommand();
						while(tokens.Current.Kind == TokenKind.Semicolon) {
							AcceptIt();
							ParseSingleCommand();
						}
					}
					/**
					 * Parses a single command.
					 */
					protected void ParseSingleCommand() {
						Compiler.Info(typeof(Parser).Name, "parsing single command");
						switch(tokens.Current.Kind) {
							case TokenKind.Identifier: {
								ParseIdentifier();
								if(tokens.Current.Kind == TokenKind.Becomes) {
									AcceptIt();
									ParseExpression();
								}
								else {
									Accept(TokenKind.LeftParenthese);
									ParseExpression();
									
									Accept(TokenKind.RightParenthese);
								}
								break;
							}
							case TokenKind.Begin:
								AcceptIt();
								ParseCommand();
								Accept(TokenKind.End);
								break;
							case TokenKind.If:
								AcceptIt();
								ParseExpression();
								Accept(TokenKind.Then);
								ParseSingleCommand();
								Accept(TokenKind.Else);
								ParseSingleCommand();
								break;
							case TokenKind.While:
								AcceptIt();
								ParseExpression();
								Accept(TokenKind.Do);
								ParseSingleCommand();
								break;
							case TokenKind.Let:
								AcceptIt();
								ParseDeclaration();
								Accept(TokenKind.In);
								ParseSingleCommand();
								break;
							case TokenKind.Skip:
								AcceptIt();
								break;
							default:
								Compiler.Error(typeof(Parser).Name, 2, new string[]{
									tokens.Current.Position.Start.LineNumber.ToString(),
									tokens.Current.Position.Start.RowNumber.ToString(),
									tokens.Current.Kind.ToString(),
									TokenKind.Identifier.ToString(),
									TokenKind.Begin.ToString(),
									TokenKind.If.ToString(),
									TokenKind.While.ToString(),
									TokenKind.Skip.ToString(),
									TokenKind.Let.ToString()
								});
								break;
						}
						Console.WriteLine();
					}
				// terminals parsing
					/**
					 * Parses an identifier, and constructs a leaf AST to represent it.
					 */
					protected void ParseIdentifier() {
						Compiler.Info(typeof(Parser).Name, "parsing identifier");
						Accept(TokenKind.Identifier);
					}
					/**
					 * Parses an operator.
					 */
					protected void ParseOperator() {
						Compiler.Info(typeof(Parser).Name, "parsing operator");
						switch(tokens.Current.Spelling) {
							case "+":
							case "-":
							case "/":
							case "*":
							case "<":
							case ">":
							case "=":
							case "==":
							case "+=":
							case "-=":
							case "/=":
							case "*=":
							case "<=":
							case ">=":
								AcceptIt();
								break;
							default:
								Compiler.Error(typeof(Parser).Name, 1, new string[]{
									tokens.Current.Position.Start.LineNumber.ToString(),
									tokens.Current.Position.Start.RowNumber.ToString(),
									tokens.Current.Spelling
								});
								break;
						}
					}
					/**
					 * Parses an integer literal.
					 */
					protected void ParseIntLiteral() {
						Compiler.Info(typeof(Parser).Name, "parsing integer literal");
						Accept(TokenKind.IntLiteral);
					}
				// expresssion parsing
					/**
					 * Parses an expression. Multiple tokens swallowed at once.
					 */
					protected void ParseExpression() {
						Compiler.Info(typeof(Parser).Name, "parsing expression");
						ParseSecondaryExpression();
						if(tokens.Current.Spelling == "?") {
							AcceptIt();
							ParseExpression();
							Accept(TokenKind.Colon);
							ParseExpression();
						}
					}
					/**
					 * Parses a secondary expression.
					 */
					protected void ParseSecondaryExpression() {
						Compiler.Info(typeof(Parser).Name, "parsing secondary expression");
						ParsePrimaryExpression();
						while(tokens.Current.Kind == TokenKind.Operator) {
							AcceptIt();
							ParsePrimaryExpression();
						}
					}
					/**
					 * Parses a primary expression.
					 */
					protected void ParsePrimaryExpression() {
						Compiler.Info(typeof(Parser).Name, "parsing primary expression");
						switch(tokens.Current.Kind) {
							case TokenKind.IntLiteral:
								ParseIntLiteral();
								break;
							case TokenKind.Identifier:
								ParseIdentifier();
								if(tokens.Current.Kind == TokenKind.LeftParenthese) {
									AcceptIt();
									ParseParameters();
									Accept(TokenKind.RightParenthese);
								}
								break;
							case TokenKind.Operator:
								ParseOperator();
								ParsePrimaryExpression();
								break;
							case TokenKind.CharacterLiteral:
								AcceptIt(); // create ParseCharacterLiteral() if enough time (with length checks)
								break;
							case TokenKind.LeftParenthese:
								AcceptIt();
								ParseExpression();
								Accept(TokenKind.RightParenthese);
								break;
							default:
								Compiler.Error(typeof(Parser).Name, 2, new string[]{
									tokens.Current.Position.Start.LineNumber.ToString(),
									tokens.Current.Position.Start.RowNumber.ToString(),
									tokens.Current.Kind.ToString(),
									TokenKind.IntLiteral.ToString(),
									TokenKind.Identifier.ToString(),
									TokenKind.Operator.ToString(),
									TokenKind.LeftParenthese.ToString(),
									tokens.Current.Kind.ToString()
								});
								break;
						}
					}
				// declaration parsing
					/**
					 * Parses a declaration. Multiple tokens swallowed at once.
					 */
					protected void ParseDeclaration() {
						Compiler.Info(typeof(Parser).Name, "parsing declaration");
						do { ParsingSingleDeclaration(); } while(tokens.Current.Kind == TokenKind.Semicolon);
					}
					/**
					 * Parses a single declaration.
					 */
					protected void ParsingSingleDeclaration() {
						Compiler.Info(typeof(Parser).Name, "parsing single declaration");
						switch(tokens.Current.Kind) {
							case TokenKind.Const:
								AcceptIt();
								ParseIdentifier();
								Accept(TokenKind.Is);
								ParseExpression();
								break;
							case TokenKind.Var:
								AcceptIt();
								ParseIdentifier();
								Accept(TokenKind.Colon);
								ParseIdentifier();
								break;
							case TokenKind.Let:
								AcceptIt();
								ParseDeclaration();
								Accept(TokenKind.In);
								ParseSingleCommand();
								break;
							default:
								Compiler.Error(typeof(Parser).Name, 2, new string[]{
									tokens.Current.Position.Start.LineNumber.ToString(),
									tokens.Current.Position.Start.RowNumber.ToString(),
									tokens.Current.Kind.ToString(),
									TokenKind.Const.ToString(),
									TokenKind.Var.ToString(),
									TokenKind.Let.ToString()
								});
								break;
						}
					}
				// parameters parsing
					/**
					 * Parses parameters. Swallow multiple tokens at once.
					 */
					 protected void ParseParameters() {
						Compiler.Info(typeof(Parser).Name, "parsing parameters");
						ParseSingleParameter();
						while(tokens.Current.Kind == TokenKind.Comma) {
							AcceptIt();
							ParseSingleParameter();
						}
					}
					/**
					 * Parses a single parameter.
					 */
					protected void ParseSingleParameter() {
						if(tokens.Current.Kind == TokenKind.Var) {
							AcceptIt();
							ParseIdentifier();
						}
						else
							ParseExpression();
					}
	}
}
