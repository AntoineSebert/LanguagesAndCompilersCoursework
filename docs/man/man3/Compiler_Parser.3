.TH "Compiler.Parser" 3 "Sun Oct 28 2018" "Version 1.0.0" "Compiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Compiler.Parser
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBParser\fP (\fBScanner\fP _scanner)"
.br
.ti -1c
.RI "List< \fBToken\fP > \fBParseProgram\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBAccept\fP (\fBTokenKind\fP expectedKind)"
.br
.ti -1c
.RI "void \fBAcceptIt\fP ()"
.br
.ti -1c
.RI "void \fBParseCommand\fP ()"
.br
.ti -1c
.RI "void \fBParseSingleCommand\fP ()"
.br
.ti -1c
.RI "void \fBParseIdentifier\fP ()"
.br
.ti -1c
.RI "void \fBParseOperator\fP ()"
.br
.ti -1c
.RI "void \fBParseIntLiteral\fP ()"
.br
.ti -1c
.RI "void \fBParseExpression\fP ()"
.br
.ti -1c
.RI "void \fBParseSecondaryExpression\fP ()"
.br
.ti -1c
.RI "void \fBParsePrimaryExpression\fP ()"
.br
.ti -1c
.RI "void \fBParseDeclaration\fP ()"
.br
.ti -1c
.RI "void \fBParsingSingleDeclaration\fP ()"
.br
.ti -1c
.RI "void \fBParseParameters\fP ()"
.br
.ti -1c
.RI "void \fBParseSingleParameter\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBScanner\fP \fBscanner\fP = null"
.br
.ti -1c
.RI "IEnumerator< \fBToken\fP > \fBtokens\fP = null"
.br
.ti -1c
.RI "List< \fBToken\fP > \fBcollection\fP = null"
.br
.in -1c
.SH "Detailed Description"
.PP 
Checks that the collection of tokens generated by the scanner follow the rules of the grammar\&. 
.PP
\fBSee also:\fP
.RS 4
\fBToken\fP 
.PP
\fBTokenKind\fP 
.PP
\fBScanner\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "Compiler\&.Parser\&.Parser (\fBScanner\fP _scanner)"
Build a
.PP
.nf
Parser 

.fi
.PP
 instance\&. 
.PP
\fBParameters:\fP
.RS 4
\fI_scanner\fP \fBScanner\fP from which to perform the parsing process\&. 
.RE
.PP

.PP
.nf
36                                                     {
37                         scanner = _scanner;
38                         tokens = scanner\&.GetEnumerator();
39                     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Compiler\&.Parser\&.Accept (\fBTokenKind\fP expectedKind)\fC [protected]\fP"
Checks that the given token matches the current stream of tokens, if not prints an error\&. 
.PP
\fBParameters:\fP
.RS 4
\fIexpectedKinds\fP an array of expected token kinds\&. 
.RE
.PP

.PP
.nf
59                                                                   {
60                         Location previousLocation = null;
61                         if(tokens\&.Current\&.Kind == expectedKind)
62                             previousLocation = tokens\&.Current\&.Position\&.Start;
63                         else
64                             Compiler\&.Error(typeof(Parser)\&.Name, 2, new string[]{
65                                 tokens\&.Current\&.Position\&.Start\&.LineNumber\&.ToString(),
66                                 tokens\&.Current\&.Position\&.Start\&.RowNumber\&.ToString(),
67                                 tokens\&.Current\&.Kind\&.ToString(),
68                                 expectedKind\&.ToString()
69                             });
70                         AcceptIt();
71                     }
.fi
.SS "void Compiler\&.Parser\&.AcceptIt ()\fC [protected]\fP"
Fetches the next token from the source file\&. 
.PP
.nf
75                                               {
76                         if(tokens\&.Current != null)
77                             collection\&.Add(tokens\&.Current);
78                         //var previousLocation = tokens\&.Current\&.Position\&.End; // ?
79                         tokens\&.MoveNext();
80                     }
.fi
.SS "void Compiler\&.Parser\&.ParseCommand ()\fC [protected]\fP"
Parses a command\&. Multiple tokens swallowed at once\&. 
.PP
.nf
85                                                   {
86                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing command");
87                         AcceptIt();
88                         ParseSingleCommand();
89                         Console\&.WriteLine();
90                         while(tokens\&.Current\&.Kind == TokenKind\&.Semicolon) {
91                             AcceptIt();
92                             ParseSingleCommand();
93                             Console\&.WriteLine();
94                         }
95 
96                         Compiler\&.Info(typeof(Parser)\&.Name, "compilation succeeded");
97                     }
.fi
.SS "void Compiler\&.Parser\&.ParseDeclaration ()\fC [protected]\fP"
Parses a declaration\&. Multiple tokens swallowed at once\&. 
.PP
.nf
283                                                       {
284                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing declaration");
285                         do { ParsingSingleDeclaration(); } while(tokens\&.Current\&.Kind == TokenKind\&.Semicolon);
286                     }
.fi
.SS "void Compiler\&.Parser\&.ParseExpression ()\fC [protected]\fP"
Parses an expression\&. Multiple tokens swallowed at once\&. 
.PP
.nf
215                                                      {
216                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing expression");
217                         ParseSecondaryExpression();
218                         if(tokens\&.Current\&.Kind == TokenKind\&.QuestionMark) {
219                             AcceptIt();
220                             ParseExpression();
221                             Accept(TokenKind\&.Colon);
222                             ParseExpression();
223                         }
224                     }
.fi
.SS "void Compiler\&.Parser\&.ParseIdentifier ()\fC [protected]\fP"
Parses an identifier, and constructs a leaf AST to represent it\&. 
.PP
.nf
169                                                      {
170                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing identifier");
171                         Accept(TokenKind\&.Identifier);
172                     }
.fi
.SS "void Compiler\&.Parser\&.ParseIntLiteral ()\fC [protected]\fP"
Parses an integer literal\&. 
.PP
.nf
207                                                      {
208                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing integer literal");
209                         Accept(TokenKind\&.IntLiteral);
210                     }
.fi
.SS "void Compiler\&.Parser\&.ParseOperator ()\fC [protected]\fP"
Parses an operator\&. 
.PP
.nf
176                                                    {
177                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing operator");
178                         switch(tokens\&.Current\&.Spelling) {
179                             case "+":
180                             case "-":
181                             case "/":
182                             case "*":
183                             case "<":
184                             case ">":
185                             case "=":
186                             case "==":
187                             case "+=":
188                             case "-=":
189                             case "/=":
190                             case "*=":
191                             case "<=":
192                             case ">=":
193                                 AcceptIt();
194                                 break;
195                             default:
196                                 Compiler\&.Error(typeof(Parser)\&.Name, 1, new string[]{
197                                     tokens\&.Current\&.Position\&.Start\&.LineNumber\&.ToString(),
198                                     tokens\&.Current\&.Position\&.Start\&.RowNumber\&.ToString(),
199                                     tokens\&.Current\&.Spelling
200                                 });
201                                 break;
202                         }
203                     }
.fi
.SS "void Compiler\&.Parser\&.ParseParameters ()\fC [protected]\fP"
Parses parameters\&. Swallow multiple tokens at once\&. 
.PP
.nf
327                                                       {
328                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing parameters");
329                         ParseSingleParameter();
330                         while(tokens\&.Current\&.Kind == TokenKind\&.Comma) {
331                             AcceptIt();
332                             ParseSingleParameter();
333                         }
334                     }
.fi
.SS "void Compiler\&.Parser\&.ParsePrimaryExpression ()\fC [protected]\fP"
Parses a primary expression\&. 
.PP
.nf
239                                                             {
240                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing primary expression");
241                         switch(tokens\&.Current\&.Kind) {
242                             case TokenKind\&.IntLiteral:
243                                 ParseIntLiteral();
244                                 break;
245                             case TokenKind\&.Identifier:
246                                 ParseIdentifier();
247                                 if(tokens\&.Current\&.Kind == TokenKind\&.LeftParenthese) {
248                                     AcceptIt();
249                                     ParseParameters();
250                                     Accept(TokenKind\&.RightParenthese);
251                                 }
252                                 break;
253                             case TokenKind\&.Operator:
254                                 ParseOperator();
255                                 ParsePrimaryExpression();
256                                 break;
257                             case TokenKind\&.CharacterLiteral:
258                                 AcceptIt(); // create ParseCharacterLiteral() if enough time (with length checks)
259                                 break;
260                             case TokenKind\&.LeftParenthese:
261                                 AcceptIt();
262                                 ParseExpression();
263                                 Accept(TokenKind\&.RightParenthese);
264                                 break;
265                             default:
266                                 Compiler\&.Error(typeof(Parser)\&.Name, 2, new string[]{
267                                     tokens\&.Current\&.Position\&.Start\&.LineNumber\&.ToString(),
268                                     tokens\&.Current\&.Position\&.Start\&.RowNumber\&.ToString(),
269                                     tokens\&.Current\&.Kind\&.ToString(),
270                                     TokenKind\&.IntLiteral\&.ToString(),
271                                     TokenKind\&.Identifier\&.ToString(),
272                                     TokenKind\&.CharacterLiteral\&.ToString(),
273                                     TokenKind\&.Operator\&.ToString(),
274                                     TokenKind\&.LeftParenthese\&.ToString()
275                                 });
276                                 break;
277                         }
278                     }
.fi
.SS "List<\fBToken\fP> Compiler\&.Parser\&.ParseProgram ()"
Parses a program from the beginning to the end\&. 
.PP
\fBReturns:\fP
.RS 4
a collection representing the source code as tokens\&. 
.RE
.PP

.PP
.nf
45                                                       {
46                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing Program");
47                         collection = new List<Token>();
48                         // var previousLocation = Location\&.Empty;
49                         // var startLocation = tokens\&.Current\&.Position\&.Start; // ?
50                         ParseCommand();
51                         return collection;
52                     }
.fi
.SS "void Compiler\&.Parser\&.ParseSecondaryExpression ()\fC [protected]\fP"
Parses a secondary expression\&. 
.PP
.nf
228                                                               {
229                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing secondary expression");
230                         ParsePrimaryExpression();
231                         while(tokens\&.Current\&.Kind == TokenKind\&.Operator) {
232                             AcceptIt();
233                             ParsePrimaryExpression();
234                         }
235                     }
.fi
.SS "void Compiler\&.Parser\&.ParseSingleCommand ()\fC [protected]\fP"
Parses a single command\&. 
.PP
.nf
101                                                         {
102                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing single command");
103                         switch(tokens\&.Current\&.Kind) {
104                             case TokenKind\&.Identifier:
105                                 ParseIdentifier();
106                                 if(tokens\&.Current\&.Kind == TokenKind\&.Becomes) {
107                                     AcceptIt();
108                                     ParseExpression();
109                                 }
110                                 else {
111                                     AcceptIt();
112                                     ParseParameters();
113                                     Accept(TokenKind\&.RightParenthese);
114                                 }
115                                 break;
116                             case TokenKind\&.Begin:
117                                 do {
118                                     AcceptIt();
119                                     if(tokens\&.Current\&.Kind == TokenKind\&.End)
120                                         break;
121                                     ParseSingleCommand();
122                                     Console\&.WriteLine();
123                                 } while(tokens\&.Current\&.Kind == TokenKind\&.Semicolon);
124                                 Accept(TokenKind\&.End);
125                                 break;
126                             case TokenKind\&.If:
127                                 AcceptIt();
128                                 ParseExpression();
129                                 Accept(TokenKind\&.Then);
130                                 ParseSingleCommand();
131                                 Accept(TokenKind\&.Semicolon);
132                                 Accept(TokenKind\&.Else);
133                                 ParseSingleCommand();
134                                 break;
135                             case TokenKind\&.While:
136                                 AcceptIt();
137                                 ParseExpression();
138                                 Accept(TokenKind\&.Do);
139                                 ParseSingleCommand();
140                                 break;
141                             case TokenKind\&.Let:
142                                 AcceptIt();
143                                 ParseDeclaration();
144                                 Accept(TokenKind\&.In);
145                                 ParseSingleCommand();
146                                 break;
147                             case TokenKind\&.Skip:
148                                 AcceptIt();
149                                 break;
150                             default:
151                                 Compiler\&.Error(typeof(Parser)\&.Name, 2, new string[]{
152                                     tokens\&.Current\&.Position\&.Start\&.LineNumber\&.ToString(),
153                                     tokens\&.Current\&.Position\&.Start\&.RowNumber\&.ToString(),
154                                     tokens\&.Current\&.Kind\&.ToString(),
155                                     TokenKind\&.Identifier\&.ToString(),
156                                     TokenKind\&.Begin\&.ToString(),
157                                     TokenKind\&.If\&.ToString(),
158                                     TokenKind\&.While\&.ToString(),
159                                     TokenKind\&.Skip\&.ToString(),
160                                     TokenKind\&.Let\&.ToString()
161                                 });
162                                 break;
163                         }
164                     }
.fi
.SS "void Compiler\&.Parser\&.ParseSingleParameter ()\fC [protected]\fP"
Parses a single parameter\&. 
.PP
.nf
338                                                           {
339                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing single parameter");
340                         if(tokens\&.Current\&.Kind == TokenKind\&.Var) {
341                             AcceptIt();
342                             ParseIdentifier();
343                         }
344                         else
345                             ParseExpression();
346                     }
.fi
.SS "void Compiler\&.Parser\&.ParsingSingleDeclaration ()\fC [protected]\fP"
Parses a single declaration\&. 
.PP
.nf
290                                                               {
291                         Compiler\&.Info(typeof(Parser)\&.Name, "parsing single declaration");
292                         switch(tokens\&.Current\&.Kind) {
293                             case TokenKind\&.Const:
294                                 AcceptIt();
295                                 ParseIdentifier();
296                                 Accept(TokenKind\&.Is);
297                                 ParseExpression();
298                                 break;
299                             case TokenKind\&.Var:
300                                 AcceptIt();
301                                 ParseIdentifier();
302                                 Accept(TokenKind\&.Colon);
303                                 ParseIdentifier();
304                                 break;
305                             case TokenKind\&.Let:
306                                 AcceptIt();
307                                 ParseDeclaration();
308                                 Accept(TokenKind\&.In);
309                                 ParseSingleCommand();
310                                 break;
311                             default:
312                                 Compiler\&.Error(typeof(Parser)\&.Name, 2, new string[]{
313                                     tokens\&.Current\&.Position\&.Start\&.LineNumber\&.ToString(),
314                                     tokens\&.Current\&.Position\&.Start\&.RowNumber\&.ToString(),
315                                     tokens\&.Current\&.Kind\&.ToString(),
316                                     TokenKind\&.Const\&.ToString(),
317                                     TokenKind\&.Var\&.ToString(),
318                                     TokenKind\&.Let\&.ToString()
319                                 });
320                                 break;
321                         }
322                     }
.fi
.SH "Member Data Documentation"
.PP 
.SS "List<\fBToken\fP> Compiler\&.Parser\&.collection = null\fC [private]\fP"

.SS "\fBScanner\fP Compiler\&.Parser\&.scanner = null\fC [private]\fP"
Holds a reference to the scanner\&. 
.PP
\fBSee also:\fP
.RS 4
\fBScanner\fP 
.RE
.PP

.SS "IEnumerator<\fBToken\fP> Compiler\&.Parser\&.tokens = null\fC [private]\fP"
Holds a collection of valid tokens\&. 
.PP
\fBSee also:\fP
.RS 4
\fBToken\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Compiler from the source code\&.
