.TH "Compiler.Scanner" 3 "Sun Oct 28 2018" "Version 1.0.0" "Compiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Compiler.Scanner
.SH SYNOPSIS
.br
.PP
.PP
Inherits IEnumerable< Token >\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBScanner\fP (\fBSourceFile\fP _source)"
.br
.ti -1c
.RI "IEnumerator< \fBToken\fP > \fBGetEnumerator\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "bool \fBIsOperator\fP (char c)"
.br
.ti -1c
.RI "bool \fBIsIgnored\fP (char c)"
.br
.ti -1c
.RI "bool \fBIsSpecial\fP (char c)"
.br
.ti -1c
.RI "bool \fBIsGraphic\fP (char c)"
.br
.ti -1c
.RI "void \fBIgnoreUseless\fP ()"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "static bool \fBDebug\fP = true\fC [get, set]\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "IEnumerator IEnumerable\&. \fBGetEnumerator\fP ()"
.br
.ti -1c
.RI "\fBTokenKind\fP \fBScanToken\fP ()"
.br
.ti -1c
.RI "void \fBTakeIt\fP ()"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static bool \fBatEndOfFile\fP = false"
.br
.ti -1c
.RI "static readonly char [] \fBoperators\fP = { '+', '\-', '*', '/', '=', '<', '>' }"
.br
.ti -1c
.RI "static readonly char [] \fBignored\fP = { '!', ' ', '\\t', '\\n' }"
.br
.ti -1c
.RI "static readonly char [] \fBspecials\fP = { '\&.', '!', '?', '_', ' ' }"
.br
.ti -1c
.RI "static \fBSourceFile\fP \fBsource\fP = null"
.br
.ti -1c
.RI "static StringBuilder \fBcurrentSpelling\fP = null"
.br
.ti -1c
.RI "static readonly ImmutableDictionary< string, \fBTokenKind\fP > \fBReservedWords\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Split the source file into tokens, checks the validity of the stream on the fly\&. Does not perform syntax checks\&. 
.PP
\fBSee also:\fP
.RS 4
\fBToken\fP 
.PP
\fBTokenKind\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "Compiler\&.Scanner\&.Scanner (\fBSourceFile\fP _source)"
Builds a
.PP
.nf
Scanner 

.fi
.PP
 instance\&. 
.PP
\fBParameters:\fP
.RS 4
\fI_source\fP reference to the source file to scan\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSourceFile\fP 
.RE
.PP

.PP
.nf
66                                                        {
67                         source = _source;
68                         source\&.Reset();
69                         currentSpelling = new StringBuilder();
70                     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "IEnumerator<\fBToken\fP> Compiler\&.Scanner\&.GetEnumerator ()"
Responsible for the main process of creating a collection of tokens from the source file\&. 
.PP
\fBReturns:\fP
.RS 4
the tokens one at time\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBToken\fP 
.PP
\fBSourceFile\fP 
.RE
.PP

.PP
.nf
78                                                               {
79                         Location start = null;
80                         Token token = null;
81                         TokenKind kind = 0;
82                         while(!atEndOfFile) {
83                             currentSpelling\&.Clear();
84                             IgnoreUseless();
85                             start = source\&._Location;
86                             kind = ScanToken();
87                             token = new Token(kind, currentSpelling\&.ToString(), new SourcePosition(start, source\&._Location));
88 
89                             if(kind == TokenKind\&.EndOfText)
90                                 atEndOfFile = true;
91                             else if(kind == TokenKind\&.Error)
92                                 Environment\&.Exit(1);
93 
94                             if(Debug)
95                                 Compiler\&.Info(typeof(Scanner)\&.Name, token\&.ToString());
96                             
97                             yield return token;
98                         }
99                     }
.fi
.SS "IEnumerator IEnumerable\&. Compiler\&.Scanner\&.GetEnumerator ()\fC [private]\fP"
Returns the collection of tokens built from the source file\&. 
.PP
.nf
103 { return GetEnumerator(); }
.fi
.SS "void Compiler\&.Scanner\&.IgnoreUseless ()\fC [protected]\fP"
Skips whitespaces and comments in the source file\&. 
.PP
.nf
135                                                {
136                     while(IsIgnored(source\&.Current)) {
137                         switch(source\&.Current) {
138                             case ' ':
139                             case '\t':
140                             case '\n':
141                                 source\&.MoveNext();
142                                 break;
143                             default:
144                                 source\&.SkipRestOfLine();
145                                 break;
146                         }
147                     }
148                 }
.fi
.SS "bool Compiler\&.Scanner\&.IsGraphic (char c)\fC [protected]\fP"
Test if a character is a graphic character\&. It includes digits, letters, operators and special characters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP the character to test\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.PP
.nf
true 
.fi
.PP
 if the character is a graphic character,
.PP
.nf
false 

.fi
.PP
 otherwise\&. 
.RE
.PP

.PP
.nf
131 { return char\&.IsLetterOrDigit(c) || IsOperator(c) || IsSpecial(c); }
.fi
.SS "bool Compiler\&.Scanner\&.IsIgnored (char c)\fC [protected]\fP"
Test if a character or a sequence is to be ignored by the compiler\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP the character to test\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.PP
.nf
true 
.fi
.PP
 if the character matches an ignored character,
.PP
.nf
false 

.fi
.PP
 otherwise\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBignored\fP 
.RE
.PP

.PP
.nf
118 { return Array\&.IndexOf(ignored, c) != -1; }
.fi
.SS "bool Compiler\&.Scanner\&.IsOperator (char c)\fC [protected]\fP"
Test if a character is an operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP the character to test\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.PP
.nf
true 
.fi
.PP
 if the character matches an operator,
.PP
.nf
false 

.fi
.PP
 otherwise\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperators\fP 
.RE
.PP

.PP
.nf
111 { return Array\&.IndexOf(operators, c) != -1; }
.fi
.SS "bool Compiler\&.Scanner\&.IsSpecial (char c)\fC [protected]\fP"
Test if a character is a special character\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP the character to test\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.PP
.nf
true 
.fi
.PP
 if the character matches a special character,
.PP
.nf
false 

.fi
.PP
 otherwise\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBspecials\fP 
.RE
.PP

.PP
.nf
125 { return Array\&.IndexOf(specials, c) != -1; }
.fi
.SS "\fBTokenKind\fP Compiler\&.Scanner\&.ScanToken ()\fC [private]\fP"
Determine the token kind to build from the characters processed\&. Reads the file stream to build the token\&. 
.PP
\fBReturns:\fP
.RS 4
a token kind\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBTokenKind\fP 
.RE
.PP

.PP
.nf
155                                               {
156                     // operators + two-characters operators
157                     if(IsOperator(source\&.Current)) {
158                         TakeIt();
159                         if(IsOperator(source\&.Current)) {
160                             if(source\&.Current == '=')
161                                 TakeIt();
162                             else {
163                                 TakeIt();
164                                 Compiler\&.Error(typeof(Scanner)\&.Name, 2, new string[]{
165                                     source\&._Location\&.LineNumber\&.ToString(),
166                                     source\&._Location\&.RowNumber\&.ToString(),
167                                     currentSpelling\&.ToString()
168                                 });
169                             }
170                         }
171                         return TokenKind\&.Operator;
172                     }
173                     // integer literal
174                     if(char\&.IsDigit(source\&.Current)) {
175                         do { TakeIt(); } while(char\&.IsDigit(source\&.Current));
176                         return TokenKind\&.IntLiteral;
177                     }
178                     // identifier
179                     if(char\&.IsLetter(source\&.Current)) {
180                         do { TakeIt(); } while(char\&.IsLetter(source\&.Current) || char\&.IsDigit(source\&.Current) || source\&.Current == '_');
181                         if(ReservedWords\&.TryGetValue(currentSpelling\&.ToString(), out TokenKind reservedWordType))
182                             return reservedWordType;
183                         return TokenKind\&.Identifier;
184                     }
185                     switch(source\&.Current) {
186                         case default(char):
187                             return TokenKind\&.EndOfText;
188                         case ';':
189                             TakeIt();
190                             return TokenKind\&.Semicolon;
191                         case ',':
192                             TakeIt();
193                             return TokenKind\&.Comma;
194                         case '?':
195                             TakeIt();
196                             return TokenKind\&.QuestionMark;
197                         case '(':
198                             TakeIt();
199                             return TokenKind\&.LeftParenthese;
200                         case ')':
201                             TakeIt();
202                             return TokenKind\&.RightParenthese;
203                         case '~':
204                             TakeIt();
205                             return TokenKind\&.Is;
206                         case ':':
207                             TakeIt();
208                             if(source\&.Current == '=') {
209                                 TakeIt();
210                                 return TokenKind\&.Becomes;
211                             }
212                             return TokenKind\&.Colon;
213                         case '\'':
214                             TakeIt();
215                             if(source\&.Current == '\'') {
216                                 TakeIt();
217                                 return TokenKind\&.CharacterLiteral;
218                             }
219                             else {
220                                 if(IsGraphic(source\&.Current)) {
221                                     TakeIt();
222                                     if(source\&.Current == '\'') {
223                                         TakeIt();
224                                         return TokenKind\&.CharacterLiteral;
225                                     }
226                                 }
227                                 TakeIt();
228                                 Compiler\&.Error(typeof(Scanner)\&.Name, 1, new string[]{
229                                     source\&._Location\&.LineNumber\&.ToString(),
230                                     source\&._Location\&.RowNumber\&.ToString(),
231                                     currentSpelling\&.ToString()
232                                 });
233                                 return TokenKind\&.Error;
234                             }
235                         default:
236                             TakeIt();
237                             Compiler\&.Error(typeof(Scanner)\&.Name, 0, new string[]{
238                                 source\&._Location\&.LineNumber\&.ToString(),
239                                 source\&._Location\&.RowNumber\&.ToString(),
240                                 currentSpelling\&.ToString()
241                             });
242                             return TokenKind\&.Error;
243                     }
244                 }
.fi
.SS "void Compiler\&.Scanner\&.TakeIt ()\fC [private]\fP"
Append the current character to the buffer and move to the next character\&. 
.PP
.nf
248                                       {
249                     currentSpelling\&.Append(source\&.Current);
250                     source\&.MoveNext();
251                 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "bool Compiler\&.Scanner\&.atEndOfFile = false\fC [static]\fP, \fC [private]\fP"
Holds a boolean set to true if the end of the source file has been reached\&. 
.SS "StringBuilder Compiler\&.Scanner\&.currentSpelling = null\fC [static]\fP, \fC [private]\fP"
Contains the characters being processed in order to determine which token to create\&. 
.SS "readonly char [] Compiler\&.Scanner\&.ignored = { '!', ' ', '\\t', '\\n' }\fC [static]\fP, \fC [private]\fP"
Contains the characters or sequences to be ignored by the compiler\&. 
.SS "readonly char [] Compiler\&.Scanner\&.operators = { '+', '\-', '*', '/', '=', '<', '>' }\fC [static]\fP, \fC [private]\fP"
Contains the atomic operators\&. 
.SS "readonly ImmutableDictionary<string, \fBTokenKind\fP> Compiler\&.Scanner\&.ReservedWords\fC [static]\fP, \fC [private]\fP"
\fBInitial value:\fP
.PP
.nf
=
                    Enumerable\&.Range((int)TokenKind\&.Begin, (int)TokenKind\&.Skip)
                    \&.Cast<TokenKind>()\&.ToImmutableDictionary(kind => kind\&.ToString()\&.ToLower(), kind => kind)
.fi
Contains the reserved keywords as strings, generated on the fly when the instance is created\&. 
.PP
\fBSee also:\fP
.RS 4
\fBTokenKind\fP 
.RE
.PP

.SS "\fBSourceFile\fP Compiler\&.Scanner\&.source = null\fC [static]\fP, \fC [private]\fP"
Holds a reference to the source file\&. 
.PP
\fBSee also:\fP
.RS 4
\fBSourceFile\fP 
.RE
.PP

.SS "readonly char [] Compiler\&.Scanner\&.specials = { '\&.', '!', '?', '_', ' ' }\fC [static]\fP, \fC [private]\fP"
Contains the special characters\&. 
.SH "Property Documentation"
.PP 
.SS "bool Compiler\&.Scanner\&.Debug = true\fC [static]\fP, \fC [get]\fP, \fC [set]\fP"
Holds a boolean set to true if the \fBScanner\fP runs in debug mode\&. In that case the process is more verbose\&. 
.PP
.nf
24 { get; set; } = true;
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Compiler from the source code\&.
