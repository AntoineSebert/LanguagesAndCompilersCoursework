.TH "Compiler.SourceFile" 3 "Sun Oct 28 2018" "Version 1.0.0" "Compiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Compiler.SourceFile
.SH SYNOPSIS
.br
.PP
.PP
Inherits IEnumerator< char >\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSourceFile\fP (string sourceFileName)"
.br
.ti -1c
.RI "bool \fBMoveNext\fP ()"
.br
.ti -1c
.RI "void \fBReset\fP ()"
.br
.ti -1c
.RI "void \fBDispose\fP ()"
.br
.ti -1c
.RI "bool \fBSkipRestOfLine\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBDispose\fP (bool disposing)"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "object IEnumerator\&. \fBCurrent\fP\fC [get]\fP"
.br
.ti -1c
.RI "char \fBCurrent\fP\fC [get]\fP"
.br
.ti -1c
.RI "string \fBName\fP = ''\fC [get]\fP"
.br
.ti -1c
.RI "\fBLocation\fP \fB_Location\fP\fC [get]\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBReadLine\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "uint \fBindex\fP = 0"
.br
.ti -1c
.RI "uint \fBlineNumber\fP = 0"
.br
.ti -1c
.RI "string \fBbuffer\fP = ''"
.br
.ti -1c
.RI "StreamReader \fBsource\fP = null"
.br
.in -1c
.SH "Detailed Description"
.PP 
Holds the source file content as a collection of characters\&. Reads the file line by line\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Compiler\&.SourceFile\&.SourceFile (string sourceFileName)"
Builds a
.PP
.nf
SourceFile 

.fi
.PP
 instance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsourceFileName\fP string representing the file name of the file to open\&. 
.RE
.PP

.PP
.nf
57                                                              {
58                         Name = sourceFileName;
59                         try {
60                             if(new FileInfo(sourceFileName)\&.Length == 0) {
61                                 Compiler\&.Error(typeof(Compiler)\&.Name, 6, new string[]{ Name });
62                                 Environment\&.Exit(1);
63                             }
64                             source = new StreamReader(new FileStream(sourceFileName, FileMode\&.Open));
65                             Reset();
66                         }
67                         catch(Exception e) {
68                             Compiler\&.Error(typeof(Compiler)\&.Name, 7, new string[]{ Name, e\&.Message });
69                             Environment\&.Exit(1);
70                         }
71                     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Compiler\&.SourceFile\&.Dispose ()"
Destroys the current object\&. 
.PP
\fBDeprecated\fP
.RS 4

.RE
.PP

.PP
.nf
106                                           {
107                         Dispose(true);
108                         GC\&.SuppressFinalize(this); // breaks single responsability principle\&. Ugly\&.
109                     }
.fi
.SS "virtual void Compiler\&.SourceFile\&.Dispose (bool disposing)\fC [protected]\fP, \fC [virtual]\fP"
Destroys the
.PP
.nf
StreamReader 

.fi
.PP
 if the source is not
.PP
.nf
null 

.fi
.PP
 \&. 
.PP
\fBParameters:\fP
.RS 4
\fIdisposing\fP If this variable is set to
.PP
.nf
false 

.fi
.PP
 , the
.PP
.nf
StreamReader 

.fi
.PP
 will not be destroyed\&. 
.RE
.PP

.PP
.nf
123                                                                {
124                     if(disposing && source != null) {
125                         source\&.Dispose();
126                         source = null;
127                     }
128                 }
.fi
.SS "bool Compiler\&.SourceFile\&.MoveNext ()"
Moves the index to the next character\&. If the index has reached the end of the line, a new line is read\&. 
.PP
\fBReturns:\fP
.RS 4

.PP
.nf
true 

.fi
.PP
 if the buffer is not full,
.PP
.nf
false 

.fi
.PP
 otherwise\&. 
.RE
.PP

.PP
.nf
77                                            {
78                         if(buffer != null) {
79                             index++;
80                             if(buffer\&.Length <= index)
81                                 ReadLine();
82                         }
83                         return buffer != null;
84                     }
.fi
.SS "void Compiler\&.SourceFile\&.ReadLine ()\fC [private]\fP"
Copy the next line in the stream into the buffer, resets the index\&. If the buffer is not
.PP
.nf
null 

.fi
.PP
 , appends a new line to it\&. 
.PP
.nf
133                                         {
134                     buffer = source\&.ReadLine();
135                     if(buffer != null)
136                         buffer += '\n';
137 
138                     index = 0;
139                     lineNumber++;
140                 }
.fi
.SS "void Compiler\&.SourceFile\&.Reset ()"
Resets the reading of the source code file\&. 
.PP
\fBExceptions:\fP
.RS 4
\fIInvalidOperationException\fP This exception is thrown if the source code file is
.PP
.nf
null 

.fi
.PP
 \&. 
.br
\fINotSupportedException\fP This exception is thrown to mark the seeking of the current stream as not supported yet\&. 
.RE
.PP

.PP
.nf
90                                         {
91                         if(source == null)
92                             throw new InvalidOperationException();
93                         if(!source\&.BaseStream\&.CanSeek)
94                             throw new NotSupportedException();
95 
96                         source\&.BaseStream\&.Seek(0L, SeekOrigin\&.Begin);
97                         source\&.DiscardBufferedData();
98                         index = lineNumber = 0;
99 
100                         ReadLine();
101                     }
.fi
.SS "bool Compiler\&.SourceFile\&.SkipRestOfLine ()"
Destroys the current object\&. 
.PP
\fBReturns:\fP
.RS 4
If the end of the file has been reached, returns
.PP
.nf
true 

.fi
.PP
 , otherwise
.PP
.nf
false 

.fi
.PP
 \&. 
.RE
.PP

.PP
.nf
114                                                  {
115                         index = (uint)buffer\&.Length;
116                         return MoveNext();
117                     }
.fi
.SH "Member Data Documentation"
.PP 
.SS "string Compiler\&.SourceFile\&.buffer = ''\fC [private]\fP"
Contains the characters of the current line\&. 
.SS "uint Compiler\&.SourceFile\&.index = 0\fC [private]\fP"
Index of the current character in the buffer\&. 
.SS "uint Compiler\&.SourceFile\&.lineNumber = 0\fC [private]\fP"
Current line number\&. 
.SS "StreamReader Compiler\&.SourceFile\&.source = null\fC [private]\fP"
Reads the content of the source code file\&. 
.SH "Property Documentation"
.PP 
.SS "\fBLocation\fP Compiler\&.SourceFile\&._Location\fC [get]\fP"
\fBLocation\fP of the current character in the file\&. 
.PP
.nf
32 { get { return new Location(lineNumber, index); } }
.fi
.SS "object IEnumerator\&. Compiler\&.SourceFile\&.Current\fC [get]\fP, \fC [private]\fP"
Current character being read\&. 
.PP
.nf
19 { get { return Current; } }
.fi
.SS "char Compiler\&.SourceFile\&.Current\fC [get]\fP"
Last character of the buffer, if the buffer is not
.PP
.nf
null 

.fi
.PP
 \&. 
.PP
.nf
24 { get { return buffer == null ? default : buffer[(int)index]; } }
.fi
.SS "string Compiler\&.SourceFile\&.Name = ''\fC [get]\fP"
Name of the souce code file\&. 
.PP
.nf
28 { get; } = "";
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Compiler from the source code\&.
