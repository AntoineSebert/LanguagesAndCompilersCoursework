.TH "Compiler.Compiler" 3 "Sun Oct 28 2018" "Version 1.0.0" "Compiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Compiler.Compiler
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCompiler\fP (string fileName)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBMain\fP (string[] args)"
.br
.ti -1c
.RI "static void \fBError\fP (string origin, uint code, string[] msg)"
.br
.ti -1c
.RI "static void \fBInfo\fP (string origin, string msg)"
.br
.ti -1c
.RI "static void \fBAbort\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "readonly \fBScanner\fP \fBscanner\fP = null"
.br
.ti -1c
.RI "readonly \fBParser\fP \fBparser\fP = null"
.br
.ti -1c
.RI "readonly \fBSourceFile\fP \fBsource\fP = null"
.br
.ti -1c
.RI "List< \fBToken\fP > \fBcollection\fP = null"
.br
.in -1c
.SH "Detailed Description"
.PP 
Holds a scanner, a parser, and the source file is responsible for the whole process\&. 
.PP
\fBSee also:\fP
.RS 4
\fBScanner\fP 
.PP
\fBParser\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "Compiler\&.Compiler\&.Compiler (string fileName)"
Builds a \fBCompiler\fP instance, containing a
.PP
.nf
SourceFile 

.fi
.PP
 , a
.PP
.nf
Scanner 

.fi
.PP
 and a
.PP
.nf
Parser 

.fi
.PP
 \&. 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP name of the file to compile 
.RE
.PP

.PP
.nf
42                                                  {
43                     source = new SourceFile(fileName);
44                     scanner = new Scanner(source);
45                     parser = new Parser(scanner);
46                 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "static void Compiler\&.Compiler\&.Abort ()\fC [static]\fP"

.PP
.nf
243                                            {
244                     
245                 }
.fi
.SS "static void Compiler\&.Compiler\&.Error (string origin, uint code, string [] msg)\fC [static]\fP"
Displays an error\&. If an error occurs, the compilation is automatically stopped and all the data discarded\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorigin\fP class name of the object sender\&. 
.br
\fIcode\fP error code\&. 
.br
\fImsg\fP arguments for the error message\&. Can be empty\&. 
.RE
.PP

.PP
.nf
81                                                                                  {
82                     Console\&.ForegroundColor = ConsoleColor\&.Red;
83                     string error_message = "[ERROR]";
84 
85                     switch(origin) {
86                         case "Compiler":
87                             error_message += $"[{origin}]";
88                             switch(code) {
89                                 case 0:
90                                     error_message += $"[{code}] : ";
91                                     error_message += "sample error";
92                                     break;
93                                 case 1:
94                                     if(msg\&.Length == 0) {
95                                         Error(origin, 3, new string[]{ code\&.ToString() });
96                                         return;
97                                     }
98                                     error_message += $"[{code}] : ";
99                                     error_message += $"unknown error origin, got : {msg[0]}";
100                                     break;
101                                 case 2:
102                                     if(msg\&.Length < 2) {
103                                         Error(origin, 3, new string[]{ code\&.ToString() });
104                                         return;
105                                     }
106                                     error_message += $"[{code}] : ";
107                                     error_message += $"unknown error code from {msg[0]} , got : {msg[1]}";
108                                     break;
109                                 case 3:
110                                     if(msg\&.Length == 0) {
111                                         Error(origin, 3, new string[]{ code\&.ToString() });
112                                         return;
113                                     }
114                                     error_message += $"[{code}] : ";
115                                     error_message += $"the error from {origin} with the error code {msg[0]} does not carry enough parameters";
116                                     break;
117                                 case 4:
118                                     error_message += $"[{code}] : ";
119                                     error_message += $"no source file specified";
120                                     break;
121                                 case 5:
122                                     error_message += $"[{code}] : ";
123                                     error_message += $"too much arguments provided";
124                                     break;
125                                 case 6:
126                                     if(msg\&.Length == 0) {
127                                         Error(origin, 3, new string[]{ code\&.ToString() });
128                                         return;
129                                     }
130                                     error_message += $"[{code}] : ";
131                                     error_message += $"the source file {msg[0]} is empty";
132                                     break;
133                                 case 7:
134                                     if(msg\&.Length < 2) {
135                                         Error(origin, 3, new string[]{ code\&.ToString() });
136                                         return;
137                                     }
138                                     error_message += $"[{code}] : ";
139                                     error_message += $"the source file {msg[0]} cannot be read : {msg[1]}";
140                                     break;
141                                 default:
142                                     Error(origin, 2, new string[]{ origin, code\&.ToString() });
143                                     break;
144                             }
145                             break;
146                         case "Scanner":
147                             error_message += $"[{origin}]";
148                             switch(code) {
149                                 case 0:
150                                     if(msg\&.Length < 3) {
151                                         Error(origin, 3, new string[]{ code\&.ToString() });
152                                         return;
153                                     }
154                                     error_message += $"[{code}] : ";
155                                     error_message += $"unknown token at line {msg[0]}, column {msg[1]}, got : {msg[2]}";
156                                     break;
157                                 case 1:
158                                     if(msg\&.Length < 3) {
159                                         Error(origin, 3, new string[]{ code\&.ToString() });
160                                         return;
161                                     }
162                                     error_message += $"[{code}] : ";
163                                     error_message += $"ill-formed character literal at line {msg[0]}, column {msg[1]} , got : {msg[2]}";
164                                     break;
165                                 case 2:
166                                     if(msg\&.Length < 3) {
167                                         Error(origin, 3, new string[]{ code\&.ToString() });
168                                         return;
169                                     }
170                                     error_message += $"[{code}] : ";
171                                     error_message += $"invalid operator at line  {msg[0]}, column {msg[1]} , got : {msg[2]}";
172                                     break;
173                                 default:
174                                     Error(origin, 2, new string[]{ origin, code\&.ToString() });
175                                     return;
176                             }
177                             break;
178                         case "Parser":
179                             error_message += $"[{origin}]";
180                             switch(code) {
181                                 case 0:
182                                     if(msg\&.Length < 3) {
183                                         Error(origin, 3, new string[]{ code\&.ToString() });
184                                         return;
185                                     }
186                                     error_message += $"[{code}] : ";
187                                     error_message += $"unknown token at line {msg[0]}, column {msg[1]}, got : {msg[3]}";
188                                     break;
189                                 case 1:
190                                     if(msg\&.Length < 3) {
191                                         Error(origin, 3, new string[]{ code\&.ToString() });
192                                         return;
193                                     }
194                                     error_message += $"[{code}] : ";
195                                     error_message += $"invalid operator at line {msg[0]}, column {msg[1]}, got : {msg[2]}";
196                                     break;
197                                 case 2:
198                                     if(msg\&.Length < 4) {
199                                         Error(origin, 3, new string[]{ code\&.ToString() });
200                                         return;
201                                     }
202                                     error_message += $"[{code}] : ";
203                                     error_message += $"unexpected token found at line {msg[0]}, column {msg[1]}, got {msg[2]}, expected ";
204                                     for(uint i = 3; i < msg\&.Length; ++i)
205                                         error_message += msg[i] + ' ';
206                                     break;
207                                 default:
208                                     Error(origin, 2, new string[]{ origin, code\&.ToString() });
209                                     return;
210                             }
211                             break;
212                         default:
213                             Error(typeof(Compiler)\&.Name, 1, new string[]{ origin });
214                             return;
215                     }
216                     Console\&.WriteLine(error_message);
217                     Console\&.ResetColor();
218                 }
.fi
.SS "static void Compiler\&.Compiler\&.Info (string origin, string msg)\fC [static]\fP"
Displays an error\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorigin\fP class name of the object sender\&. 
.br
\fImsg\fP body of the info message\&. 
.RE
.PP

.PP
.nf
224                                                                    {
225                     Console\&.ForegroundColor = ConsoleColor\&.Cyan;
226                     string message = "[INFO]";
227 
228                     switch(origin) {
229                         case "Compiler":
230                         case "Scanner":
231                         case "Parser":
232                             message += $"[{origin}] : ";
233                             message += msg;
234                             break;
235                         default:
236                             Error(typeof(Compiler)\&.Name, 1, new string[]{ origin });
237                             return;
238                     }
239                     Console\&.WriteLine(message);
240                     Console\&.ResetColor();
241                 }
.fi
.SS "static void Compiler\&.Compiler\&.Main (string [] args)\fC [static]\fP"
Builds a
.PP
.nf
Compiler 

.fi
.PP
 instance\&. Launches the scanning and the compilation\&. Prints the tokens representing the source file if the previous operations succeeded\&. 
.PP
\fBParameters:\fP
.RS 4
\fIargs\fP command-line one and only argument, the source code file\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcollection\fP 
.RE
.PP

.PP
.nf
53                                                        {
54                     Console\&.ResetColor();
55                     if(args\&.Length == 0) {
56                         Error(typeof(Compiler)\&.Name, 4, null);
57                         Environment\&.Exit(1);
58                     }
59                     else if(1 < args\&.Length) {
60                         Error(typeof(Compiler)\&.Name, 5, null);
61                         Environment\&.Exit(1);
62                     }
63 
64                     if(args[0] != null) {
65                         var compiler = new Compiler(args[0]);
66                         compiler\&.collection = compiler\&.parser\&.ParseProgram();
67 
68                         if(0 < compiler\&.collection\&.Count) {
69                             foreach(var element in compiler\&.collection)
70                                 Info(typeof(Compiler)\&.Name, element\&.Kind\&.ToString());
71                         }
72                     }
73                 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "List<\fBToken\fP> Compiler\&.Compiler\&.collection = null\fC [private]\fP"
A collection representing the source code as tokens\&. 
.PP
\fBSee also:\fP
.RS 4
\fBSourceFile\fP 
.RE
.PP

.SS "readonly \fBParser\fP Compiler\&.Compiler\&.parser = null\fC [private]\fP"
Holds a \fBParser\fP object, initialised in #constructor(string) 
.PP
\fBSee also:\fP
.RS 4
\fBParser\fP 
.RE
.PP

.SS "readonly \fBScanner\fP Compiler\&.Compiler\&.scanner = null\fC [private]\fP"
Holds a \fBScanner\fP object, initialised in #constructor(string) 
.PP
\fBSee also:\fP
.RS 4
\fBScanner\fP 
.RE
.PP

.SS "readonly \fBSourceFile\fP Compiler\&.Compiler\&.source = null\fC [private]\fP"
Holds the source code file, initialised in #constructor(string) 
.PP
\fBSee also:\fP
.RS 4
\fBSourceFile\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Compiler from the source code\&.
